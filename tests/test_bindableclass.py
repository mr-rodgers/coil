import asyncio
from unittest import mock

import pytest

from coil import BindableValue, bindableclass, runtime
from coil._core import notify_subscribers
from coil.protocols import Bindable

from .conftest import Box


@bindableclass
class Values:
    value: BindableValue[str]
    unannotated_value: int


def test_bindable_class_sets_descriptors() -> None:
    assert isinstance(Values.value, BindableValue)
    assert isinstance(Values.unannotated_value, BindableValue)


@pytest.fixture
def values() -> Values:
    return Values(value="foo", unannotated_value=100)


def test_bindable_obj_instance_values(values: Values) -> None:
    assert values.value == "foo"
    assert values.unannotated_value == 100


def test_bindable_obj_instance_is_bindable(values: Values) -> None:
    assert isinstance(values, Bindable)


@pytest.mark.parametrize("ro_bind", [True, False])
def test_bound_value_assignments_not_supported_without_runtime(
    values: Values, ro_bind: bool
) -> None:
    other_values = Values(value="bar", unannotated_value=50)
    with pytest.raises(RuntimeError):
        values.value = Values.value.bind(other_values, readonly=ro_bind)


@pytest.mark.asyncio
@pytest.mark.parametrize("ro_bind", [True, False])
async def test_assign_bound_value_with_runtime(ro_bind: bool) -> None:
    source = Box(0)
    target = Box(101)

    async with runtime():
        target.value = Box.value.bind(source, readonly=ro_bind)

        # should set underlying value instantly
        assert target.value == source.value

        for i in range(100):
            source.value = i
            await asyncio.wait_for(
                wait_for_value(target, source.value), timeout=1
            )

    assert target.value == source.value


@pytest.mark.asyncio
async def test_assign_two_way_bound_value_with_runtime() -> None:
    box1 = Box(0)
    box2 = Box(101)

    async with runtime():
        box2.value = Box.value.bind(box1, readonly=False)

        # should set underlying value instantly
        assert box2.value == box1.value

        for i in range(100):
            box2.value = i * 100
            await asyncio.wait_for(wait_for_value(box1, box2.value), timeout=1)

            box1.value = i
            await asyncio.wait_for(wait_for_value(box2, box1.value), timeout=1)

    assert box2.value == box1.value


@pytest.mark.asyncio
async def test_cyclic_events_eliminated_with_bound_value_assignments() -> None:
    source = Box(0)
    target = Box(100)
    back_feeder = Box(1)

    with mock.patch(
        "coil._bindings.notify_subscribers", wraps=notify_subscribers
    ) as notify_subs:

        async with runtime() as rt:
            target.value = Box.value.bind(source, readonly=True)
            back_feeder.value = Box.value.bind(target, readonly=True)
            source.value = Box.value.bind(back_feeder, readonly=True)
            await long_sleep()

            # careful about this mock; it doesn't spy every invocation
            # of _core.notify_subscribers(...), but rather it spies
            # only those invocations of _core.notify_subscribers(...)
            # which occur in _bindings.py. In other words, it spies
            # invocations which are generated by bindings
            notify_subs.reset_mock()

            source.value = 10
            await long_sleep()
            assert back_feeder.value == source.value
            assert len(rt._Runtime__tasks) == 4
            assert notify_subs.call_count == 3
            notify_subs.reset_mock()

            target.value = -100
            await long_sleep()
            assert source.value == target.value
            assert len(rt._Runtime__tasks) == 4
            assert notify_subs.call_count == 3
            notify_subs.reset_mock()

            back_feeder.value = 50
            await long_sleep()
            assert target.value == back_feeder.value
            assert len(rt._Runtime__tasks) == 4
            assert notify_subs.call_count == 3


@pytest.mark.asyncio
@pytest.mark.parametrize("ro_bind", [True, False])
async def test_assigning_self_bind_clears_existing_bind_task(
    ro_bind: bool,
) -> None:
    source = Box(0)
    target = Box(100)

    async with runtime():
        target.value = Box.value.bind(source, readonly=ro_bind)
        target.value = Box.value.bind(target)
        await long_sleep()

        source.value = -50
        await long_sleep()

        assert source.value != target.value


@pytest.mark.asyncio
@pytest.mark.parametrize("ro_bind", [True, False])
async def test_clear_last_binding(
    ro_bind: bool,
) -> None:
    source = Box(0)
    target = Box(100)

    async with runtime():
        target.value = Box.value.bind(source, readonly=ro_bind)
        Box.value.clear_last_binding(assigned_to=target)
        await long_sleep()

        source.value = -50
        await long_sleep()

        assert source.value != target.value


async def wait_for_value(box: Box, value: int) -> None:
    while box.value != value:
        await asyncio.sleep(0)


async def long_sleep() -> None:
    for i in range(10):
        await asyncio.sleep(0)
