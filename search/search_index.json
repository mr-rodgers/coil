{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started \u00b6 coil provides data bindings for Python 3.10+ asyncio applications. With data bindings, you are able to write applications which react to changes in an application's state, by \"binding\" properties from one component onto another. Usage \u00b6 coil allows data bindings through a special type of class that is able to record changes to its properties. coil's included @bindableclass decorator can be used to declare such a class: from coil import bindableclass @bindableclass class Window : width : int height : int When a class is decorated like this, you can bind to its declared properties, receiving notifications about changes to this property through an asyncio event stream: from asyncio import create_task from coil import bind async def track_window_changes ( window : Window ) -> None : async for event in bind (( window , \"width\" )) . events (): print ( event [ \"value\" ]) async def main () -> None : window : Window = ... task = create_task ( track_window_changes ( window )) # run the application ... # cleanup the task task . cancel () await task Do be aware that the async iterator returned from Bound.events() will run indefinitely (or, until the bound value is deleted). For this reason, this stream should be consumed in parallel to application code. Capabilities \u00b6 Generate asynchronous event streams from changes made to a bound value over time. Chain binding properties together, by tailing changes from one property into another. Bidirectional data binding Roadmap \u00b6 Composite bindings Bindings using a callback function (smart enough to track which props they access, and refire when any of those previously accessed props changed)","title":"Getting Started"},{"location":"#getting-started","text":"coil provides data bindings for Python 3.10+ asyncio applications. With data bindings, you are able to write applications which react to changes in an application's state, by \"binding\" properties from one component onto another.","title":"Getting Started"},{"location":"#usage","text":"coil allows data bindings through a special type of class that is able to record changes to its properties. coil's included @bindableclass decorator can be used to declare such a class: from coil import bindableclass @bindableclass class Window : width : int height : int When a class is decorated like this, you can bind to its declared properties, receiving notifications about changes to this property through an asyncio event stream: from asyncio import create_task from coil import bind async def track_window_changes ( window : Window ) -> None : async for event in bind (( window , \"width\" )) . events (): print ( event [ \"value\" ]) async def main () -> None : window : Window = ... task = create_task ( track_window_changes ( window )) # run the application ... # cleanup the task task . cancel () await task Do be aware that the async iterator returned from Bound.events() will run indefinitely (or, until the bound value is deleted). For this reason, this stream should be consumed in parallel to application code.","title":"Usage"},{"location":"#capabilities","text":"Generate asynchronous event streams from changes made to a bound value over time. Chain binding properties together, by tailing changes from one property into another. Bidirectional data binding","title":"Capabilities"},{"location":"#roadmap","text":"Composite bindings Bindings using a callback function (smart enough to track which props they access, and refire when any of those previously accessed props changed)","title":"Roadmap"},{"location":"api/coreref/","text":"Core Functions \u00b6 The coil module contains most of what your need to use coil. bindableclass ( cls : T ) -> T \u00b6 Decorate a class as coil.protocols.Bindable . This enables to bind to the classes' declared properties using instances of this class (either using coil.bind or coil.BindableValue.bind ): @bindableclass class Box : value : Any Classes generated by this decorator are also dataclasses. bind ( target : Tuple [ coil . protocols . _bindable . Bindable , str ], * , readonly : bool = True ) -> Any \u00b6 Return a binding for the given target Parameters: Name Type Description Default target coil.protocols.Bindable A tuple representing a protocols.Bindable and attribute combination. required readonly bool Controls what you are able to do with the returned binding; this is True be default, meaning that the returned binding can only be used to watch for changes to the bound value. When this is set to False , the returned binding can also be used to set the bound value. True tail ( bound : Bound , * , into : ReverseBound ) -> Task \u00b6 Forward all changes from a bound value into another. This function returns a cancellable asyncio.Task , which will keep running until the bound value is deleted from the host (if ever). Parameters: Name Type Description Default bound Bound a bound value from which changes are to be streamed. required into ReverseBound a bound value into which changes are sent required BindableValue ( Generic ) \u00b6 A descriptor which allows to track changes on a coil.protocols.Bindable . You typically do not need to instantiate one of these yourself; classes decorated with coil.bindableclass will have all of their declared properties turned into one of these. These also provide an alternative syntax for creating data bindings. >>> @bindableclass ... class Box : ... value : Any ... >>> box = Box ( value = 1 ) >>> bound_value = Box . value . bind ( box ) >>> bound_value . events () < BindingEventStream bindable = Box ( value = 1 ), prop = 'value' > bind ( self , obj : Bindable , * , readonly : bool = True ) -> Any \u00b6 Get a binding for this value on a given object. Short hand for bind((obj, attr), readonly=readonly) from coil import bind , bindableclass @bindableclass class Box : value : Any box = Box ( value = \"foo\" ) # these are equivalent: bind (( box , \"value\" )) Box . value . bind ( box ) # this is more type safe clear_last_binding ( self , * , assigned_to : Bindable ) -> None \u00b6 Clear an an ongoing binding that was assigned to a bindable. If you've assigned a bound value to a binding target. That means changes to the bound value will be propagated to the binding target automatically in the background. This method provides a way to stop this process: @coil . bindableclass class Box : value : int async with coil . runtime (): source = Box ( 10 ) target = Box ( 10 ) # changes to source.value will be reflected # into target.value target . value = Box . value . bind ( source ) # changes to source.value will no longer be # reflected into target.value Box . value . clear_last_binding ( assigned_to = target ) This function is a more readable shorthand for assigning a \"self-bind\" to the target: async with coil . runtime (): source = Box ( 10 ) target = Box ( 10 ) # changes to source.value will be reflected # into target.value target . value = Box . value . bind ( source ) # changes to source.value will no longer be # reflected into target.value target . value = Box . value . bind ( target ) In both cases, the underlying coil.tail tasks will be cancelled asynchronously, which means you may still receive updates on the bound value for a very short while after calling this. If you would prefer to wait until the updates are guaranteed not to occur before continuing, you should await coil.Runtime.synchronise after calling this. runtime ( * , ensure : bool = True ) -> Runtime \u00b6 Retrieve the currently active coil.Runtime . If ensure=True (default) and no runtime is currently active, a new one is returned, but it is not activated. (Runtimes are activated when they are used as context managers, for the duration of the context block.) If ensure=False (default) and no runtime is currently active, then this raises a RuntimeError . Most applications will only need just one active runtime context, so it's best to use this function to wrap your application code at startup. import asyncio import coil @coil . bindableclass class Box : value : int async def main (): box = Box ( 10 ) task1 = asyncio . create_task ( asyncio . sleep ( 1000 )) task2 = asyncio . create_task ( asyncio . sleep ( 1000 )) async with coil . runtime () as rt : rt . register ( task1 , \"some-task\" ) rt . register ( task2 , \"some-task\" , source = ( box , \"value\" )) assert rt . find ( \"some-task\" ) is task1 assert rt . find ( \"some-task\" , source = ( box , \"value\" )) is task2 rt . forget ( task1 ) assert rt . find ( \"some-task\" ) is None assert task1 . done () assert task2 . done () asyncio . run ( main ()) Runtime \u00b6 A coil runtime This object is a context manager capable of managing tasks by an id (which may or may not be scoped to a binding). When the context exits, all tasks which are remaining are cancelled and then awaited. register ( self , task : Task , id : str , * , source : Optional [ Tuple [ object , str ]] = None ) -> None \u00b6 Register a task by an id. Parameters: Name Type Description Default task Task an asyncio task to be monitored. required id str a unique identifier for the task, which can be used to look it up later with :meth: find . required source Optional[Tuple[object, str]] An optional binding to which the id is scoped. None Exceptions: Type Description ValueError when another task with the same id / source combination is already registered. AttributeError if called outside the Runtime's context manager. find ( self , id : str , * , source : Optional [ Tuple [ object , str ]] = None ) -> _asyncio . Task | None \u00b6 Retrieve a registered task. evict ( self , id : str , * , source : Optional [ Tuple [ object , str ]] = None ) -> None \u00b6 Forget and (eventually) cancel a registered task. This method first tries to find a registered task using the given search parameters. If one is found, then it is forgotten and then scheduled for cancellation. (Note: cancellation is not immediate and will occur asynchronously; if you need to await cancellation, then use a combination of [coil.Runtime.find] and [coil.Runtime.forget], while managing the cancellation yourself.) If no task is found matching the search parameters, this function does nothing. forget ( self , task : Task ) -> None \u00b6 Purge a given task from the internal registry.","title":"Core Functions"},{"location":"api/coreref/#core-functions","text":"The coil module contains most of what your need to use coil.","title":"Core Functions"},{"location":"api/coreref/#coil._bindableclass.bindableclass","text":"Decorate a class as coil.protocols.Bindable . This enables to bind to the classes' declared properties using instances of this class (either using coil.bind or coil.BindableValue.bind ): @bindableclass class Box : value : Any Classes generated by this decorator are also dataclasses.","title":"bindableclass()"},{"location":"api/coreref/#coil._bindings.bind","text":"Return a binding for the given target Parameters: Name Type Description Default target coil.protocols.Bindable A tuple representing a protocols.Bindable and attribute combination. required readonly bool Controls what you are able to do with the returned binding; this is True be default, meaning that the returned binding can only be used to watch for changes to the bound value. When this is set to False , the returned binding can also be used to set the bound value. True","title":"bind()"},{"location":"api/coreref/#coil._core.tail","text":"Forward all changes from a bound value into another. This function returns a cancellable asyncio.Task , which will keep running until the bound value is deleted from the host (if ever). Parameters: Name Type Description Default bound Bound a bound value from which changes are to be streamed. required into ReverseBound a bound value into which changes are sent required","title":"tail()"},{"location":"api/coreref/#coil._bindableclass.BindableValue","text":"A descriptor which allows to track changes on a coil.protocols.Bindable . You typically do not need to instantiate one of these yourself; classes decorated with coil.bindableclass will have all of their declared properties turned into one of these. These also provide an alternative syntax for creating data bindings. >>> @bindableclass ... class Box : ... value : Any ... >>> box = Box ( value = 1 ) >>> bound_value = Box . value . bind ( box ) >>> bound_value . events () < BindingEventStream bindable = Box ( value = 1 ), prop = 'value' >","title":"BindableValue"},{"location":"api/coreref/#coil._bindableclass.BindableValue.bind","text":"Get a binding for this value on a given object. Short hand for bind((obj, attr), readonly=readonly) from coil import bind , bindableclass @bindableclass class Box : value : Any box = Box ( value = \"foo\" ) # these are equivalent: bind (( box , \"value\" )) Box . value . bind ( box ) # this is more type safe","title":"bind()"},{"location":"api/coreref/#coil._bindableclass.BindableValue.clear_last_binding","text":"Clear an an ongoing binding that was assigned to a bindable. If you've assigned a bound value to a binding target. That means changes to the bound value will be propagated to the binding target automatically in the background. This method provides a way to stop this process: @coil . bindableclass class Box : value : int async with coil . runtime (): source = Box ( 10 ) target = Box ( 10 ) # changes to source.value will be reflected # into target.value target . value = Box . value . bind ( source ) # changes to source.value will no longer be # reflected into target.value Box . value . clear_last_binding ( assigned_to = target ) This function is a more readable shorthand for assigning a \"self-bind\" to the target: async with coil . runtime (): source = Box ( 10 ) target = Box ( 10 ) # changes to source.value will be reflected # into target.value target . value = Box . value . bind ( source ) # changes to source.value will no longer be # reflected into target.value target . value = Box . value . bind ( target ) In both cases, the underlying coil.tail tasks will be cancelled asynchronously, which means you may still receive updates on the bound value for a very short while after calling this. If you would prefer to wait until the updates are guaranteed not to occur before continuing, you should await coil.Runtime.synchronise after calling this.","title":"clear_last_binding()"},{"location":"api/coreref/#coil._runtime.runtime","text":"Retrieve the currently active coil.Runtime . If ensure=True (default) and no runtime is currently active, a new one is returned, but it is not activated. (Runtimes are activated when they are used as context managers, for the duration of the context block.) If ensure=False (default) and no runtime is currently active, then this raises a RuntimeError . Most applications will only need just one active runtime context, so it's best to use this function to wrap your application code at startup. import asyncio import coil @coil . bindableclass class Box : value : int async def main (): box = Box ( 10 ) task1 = asyncio . create_task ( asyncio . sleep ( 1000 )) task2 = asyncio . create_task ( asyncio . sleep ( 1000 )) async with coil . runtime () as rt : rt . register ( task1 , \"some-task\" ) rt . register ( task2 , \"some-task\" , source = ( box , \"value\" )) assert rt . find ( \"some-task\" ) is task1 assert rt . find ( \"some-task\" , source = ( box , \"value\" )) is task2 rt . forget ( task1 ) assert rt . find ( \"some-task\" ) is None assert task1 . done () assert task2 . done () asyncio . run ( main ())","title":"runtime()"},{"location":"api/coreref/#coil._runtime.Runtime","text":"A coil runtime This object is a context manager capable of managing tasks by an id (which may or may not be scoped to a binding). When the context exits, all tasks which are remaining are cancelled and then awaited.","title":"Runtime"},{"location":"api/coreref/#coil._runtime.Runtime.register","text":"Register a task by an id. Parameters: Name Type Description Default task Task an asyncio task to be monitored. required id str a unique identifier for the task, which can be used to look it up later with :meth: find . required source Optional[Tuple[object, str]] An optional binding to which the id is scoped. None Exceptions: Type Description ValueError when another task with the same id / source combination is already registered. AttributeError if called outside the Runtime's context manager.","title":"register()"},{"location":"api/coreref/#coil._runtime.Runtime.find","text":"Retrieve a registered task.","title":"find()"},{"location":"api/coreref/#coil._runtime.Runtime.evict","text":"Forget and (eventually) cancel a registered task. This method first tries to find a registered task using the given search parameters. If one is found, then it is forgotten and then scheduled for cancellation. (Note: cancellation is not immediate and will occur asynchronously; if you need to await cancellation, then use a combination of [coil.Runtime.find] and [coil.Runtime.forget], while managing the cancellation yourself.) If no task is found matching the search parameters, this function does nothing.","title":"evict()"},{"location":"api/coreref/#coil._runtime.Runtime.forget","text":"Purge a given task from the internal registry.","title":"forget()"},{"location":"api/protocols/","text":"coil.protocols \u2014 Protocols modeling bound values and their bindable hosts \u00b6 The coil.protocols module contains protocols which are used throughout the library. Bindable ( Protocol ) \u00b6 An object which can notify subscribers about changes to its properties. This protocol is implemented by any class that is decorated with bindableclass (even though this currently fails mypy typecheck). BindingTarget ( Protocol ) \u00b6 A property that can be bound to. current : Any property readonly \u00b6 Retrieve the current value of the binding target. host : Bindable property readonly \u00b6 Return a host mapping to the bindable. prop : str property readonly \u00b6 The name of the property Bound ( BindingTarget , Protocol ) \u00b6 An abstraction of a readable bound value. events ( self ) -> AsyncIterable [ coil . types . _events . DataUpdatedEvent ] \u00b6 Return an asynchronous stream of value change events. If the underlying value is destroyed, then the stream will be closed. ReverseBound ( Protocol ) \u00b6 An abstraction of a settable bound value. set ( self , value : Any , source_event : coil . types . _events . DataEvent | None = None ) -> Awaitable [ NoneType ] \u00b6 Push a value into the binding. TwoWayBound ( Bound , ReverseBound , Protocol ) \u00b6 A combination of Bound and ReverseBound .","title":"coil.protocols \u2014 Protocols modeling bound values and their bindable hosts"},{"location":"api/protocols/#coilprotocols-protocols-modeling-bound-values-and-their-bindable-hosts","text":"The coil.protocols module contains protocols which are used throughout the library.","title":"coil.protocols \u2014 Protocols modeling bound values and their bindable hosts"},{"location":"api/protocols/#coil.protocols._bindable.Bindable","text":"An object which can notify subscribers about changes to its properties. This protocol is implemented by any class that is decorated with bindableclass (even though this currently fails mypy typecheck).","title":"Bindable"},{"location":"api/protocols/#coil.protocols._bindable.BindingTarget","text":"A property that can be bound to.","title":"BindingTarget"},{"location":"api/protocols/#coil.protocols._bindable.BindingTarget.current","text":"Retrieve the current value of the binding target.","title":"current"},{"location":"api/protocols/#coil.protocols._bindable.BindingTarget.host","text":"Return a host mapping to the bindable.","title":"host"},{"location":"api/protocols/#coil.protocols._bindable.BindingTarget.prop","text":"The name of the property","title":"prop"},{"location":"api/protocols/#coil.protocols._bound.Bound","text":"An abstraction of a readable bound value.","title":"Bound"},{"location":"api/protocols/#coil.protocols._bound.Bound.events","text":"Return an asynchronous stream of value change events. If the underlying value is destroyed, then the stream will be closed.","title":"events()"},{"location":"api/protocols/#coil.protocols._bound.ReverseBound","text":"An abstraction of a settable bound value.","title":"ReverseBound"},{"location":"api/protocols/#coil.protocols._bound.ReverseBound.set","text":"Push a value into the binding.","title":"set()"},{"location":"api/protocols/#coil.protocols._bound.TwoWayBound","text":"A combination of Bound and ReverseBound .","title":"TwoWayBound"},{"location":"api/types/","text":"coil.types \u2014 Data types which are used in coil \u00b6 DataEvent ( dict ) \u00b6 A typed dict representing a data-event generated from a bound value. DataUpdatedEvent and DataDeletedEvent are both variants of this. They are typically yielded from protocols.Bound.events(...) . Data events may provide the following fields: source : This is always present, and refers to the BindingTarget that generated the event. source_event : This is always present, but may be None . When present, it will point to another DataEvent which this event was generated from inside. value : This is only present in DataUpdatedEvent dicts. It is important to bear in mind that these are dictionaries, and not objects. In other words, you can retrieve an event's source using event[\"source_event\"] , but not with event.source_event . DataUpdatedEvent ( dict ) \u00b6 DataDeletedEvent ( dict ) \u00b6 is_update_event ( obj : Any ) -> TypeGuard [ DataUpdatedEvent ] \u00b6 Return whether an object is a DataUpdatedEvent is_delete_event ( obj : Any ) -> TypeGuard [ DataDeletedEvent ] \u00b6 Check whether an object is a DataDeletedEvent","title":"coil.types \u2014 Data types which are used in coil"},{"location":"api/types/#coiltypes-data-types-which-are-used-in-coil","text":"","title":"coil.types \u2014 Data types which are used in coil"},{"location":"api/types/#coil.types._events.DataEvent","text":"A typed dict representing a data-event generated from a bound value. DataUpdatedEvent and DataDeletedEvent are both variants of this. They are typically yielded from protocols.Bound.events(...) . Data events may provide the following fields: source : This is always present, and refers to the BindingTarget that generated the event. source_event : This is always present, but may be None . When present, it will point to another DataEvent which this event was generated from inside. value : This is only present in DataUpdatedEvent dicts. It is important to bear in mind that these are dictionaries, and not objects. In other words, you can retrieve an event's source using event[\"source_event\"] , but not with event.source_event .","title":"DataEvent"},{"location":"api/types/#coil.types._events.DataUpdatedEvent","text":"","title":"DataUpdatedEvent"},{"location":"api/types/#coil.types._events.DataDeletedEvent","text":"","title":"DataDeletedEvent"},{"location":"api/types/#coil.types._events.is_update_event","text":"Return whether an object is a DataUpdatedEvent","title":"is_update_event()"},{"location":"api/types/#coil.types._events.is_delete_event","text":"Check whether an object is a DataDeletedEvent","title":"is_delete_event()"}]}