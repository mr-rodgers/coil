from __future__ import annotations

from dataclasses import dataclass, fields
from typing import Any, Generic, Literal, TypeVar, overload

from coil.protocols._bound import Bound, TwoWayBound

from ._bindings import bind
from ._core import bound_attr_name, notify_subscribers
from .protocols import Bindable
from .types import DataDeletedEvent, DataUpdatedEvent

T = TypeVar("T", bound=type)
V = TypeVar("V")


def override_init(cls: T) -> None:
    old_init = cls.__init__  # type: ignore

    def __init__(obj: Bindable, *args: Any, **kwargs: Any) -> None:
        obj.__coil_bindings__ = {}  # type: ignore
        old_init(obj, *args, **kwargs)

    cls.__init__ = __init__  # type: ignore


def bindableclass(cls: T) -> T:
    """Decorate a class as :class:`coil.protocols.Bindable`.

    This enables to bind to the classes' declared properties
    using instances of this class (either using :func:`bind` or
    :meth:`BindableValue.bind`)::

        @bindableclass
        class Box:
            value: Any

    Classes generated by this decorator are also dataclasses.
    """
    data_cls: Any = dataclass(cls)
    override_init(data_cls)

    for field in fields(data_cls):
        setattr(data_cls, field.name, BindableValue(field.name))

    return data_cls  # type: ignore


class BindableValue(Generic[V]):
    """
    A descriptor which allows to track changes on a
    :class:`coil.protocols.Bindable`.

    You typically do not need to instantiate one of these
    yourself; classes decorated with :func:`bindableclass`
    will have all of their declared properties turned into
    one of these.

    These also provide an alternative syntax for creating
    data bindings::

        >>> @bindableclass
        ... class Box:
        ...     value: Any
        ...
        >>> box = Box(value=1)
        >>> bound_value = Box.value.bind(box)
        >>> bound_value.events()
        <BindingEventStream bindable=Box(value=1), prop='value'>
    """

    def __init__(self, name: str):
        self.name = name

    def __set_name__(self, obj: Bindable, name: str) -> None:
        # use this to register mutation events on object
        self.name = name

    @overload
    def __get__(self, obj: None, owner: Any) -> BindableValue[V]:
        pass

    @overload
    def __get__(self, obj: object, owner: Any) -> V:
        pass

    def __get__(self, obj: Any, owner: Any) -> Any:
        if obj is None:
            return self

        # simply retrieve the value from the object
        return getattr(obj, self.private_name)

    def __set__(self, obj: Bindable, value: V) -> None:
        setattr(obj, self.private_name, value)
        notify_subscribers(
            obj,
            self.name,
            DataUpdatedEvent(
                source_event=None, value=value, source=self.bind(obj)
            ),
        )

    def __delete__(self, obj: Bindable) -> None:
        delattr(obj, self.private_name)
        notify_subscribers(
            obj,
            self.name,
            DataDeletedEvent(source_event=None, source=self.bind(obj)),
        )

    @overload
    def bind(self, obj: Bindable, *, readonly: Literal[True] = True) -> Bound:
        pass

    @overload
    def bind(self, obj: Bindable, *, readonly: Literal[False]) -> TwoWayBound:
        pass

    def bind(self, obj: Bindable, *, readonly: bool = True) -> Any:
        """Get a binding for this value on a given object.

        Short hand for
        :func:`bind((obj, attr), readonly=readonly) <coil.bind>`::

            from coil import bind, bindableclass

            @bindableclass
            class Box:
                value: Any

            box = Box(value="foo")

            # these are equivalent:
            bind((box, "value"))
            Box.value.bind(box) # this is more type safe

        """
        return bind((obj, self.name), readonly=readonly)  # type: ignore

    @property
    def private_name(self) -> str:
        return bound_attr_name(self.name)
